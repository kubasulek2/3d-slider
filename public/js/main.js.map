{"version":3,"sources":["main.js"],"names":["_rotationSpeed","Symbol","_clickedId","_easing","_speedMeasure","_motionData","_dynamicContent","_calculateEntryValues","_computeEasing","_computeRotatingTime","_applyEasing","_computeAvgSpeed","_getTargetAngle","_shouldChangeDirection","_restoreAnimation","_accelerate","_updateContent","htmlElement","constructor","element","copy","remove","this","clone","append","parent","slider3d","baseSpeed","speed","super","faces","children","start","stop","undefined","lastMeasuredAngle","speedArr","avgSpeed","isAboutToStop","currentAngle","targetAngle","move","content","willUpdate","animateElement","rotationSpeed","length","Math","round","window","requestAnimationFrame","css","animateFace","faceClickEvent","filter","i","el","$","attr","e","stopPropagation","target","direction","currentTarget","one","angleWhenClicked","[object Object]","flag","rotationTime","abs","floor","measureAngle","Date","steps","distance","threshold","delay","speedChange","startEase","slowAngles","easing","push","parseFloat","toFixed","forEach","value","arg","targetId","reduce","a","b","removeClass","targetPlane","text","myElement"],"mappings":"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","file":"main.js","sourcesContent":["//defining symbols for private members\nconst\n  _rotationSpeed = Symbol('rotationSpeed'),\n  _clickedId = Symbol('clickedId'),\n  _easing = Symbol('easing'),\n  _speedMeasure = Symbol('speedMeasure'),\n  _motionData = Symbol('motionData'),\n  _dynamicContent = Symbol('dynamicContent'),\n  _calculateEntryValues = Symbol('calculateEntryValues'),\n  _computeEasing = Symbol('computeEasing'),\n  _computeRotatingTime = Symbol('_computeRotatingTime'),\n  _applyEasing = Symbol('applyEasing'),\n  _computeAvgSpeed = Symbol('computeAvgSpeed'),\n  _getTargetAngle = Symbol('getTargetAngle'),\n  _shouldChangeDirection = Symbol('shouldChangeDirection'),\n  _restoreAnimation = Symbol('restoreAnimation'),\n  _accelerate = Symbol('accelerate'),\n  _updateContent = Symbol('updateContent');\n\n\nclass htmlElement {\n  constructor(element){\n    this.element = element\n  }\n  copy(){\n    return this.element.clone()\n  }\n  remove(){\n    this.element.remove()\n  }\n  append(parent){\n      this.element.append(parent)\n  }\n}\n\n\nclass slider3d extends htmlElement{\n  constructor(element ,speed){\n    super(element);\n\n    this.baseSpeed = speed > 1 ? 1 : speed;\n    this.faces = this.element.children('.face');\n\n    this[_rotationSpeed] = speed > 1 ? 1 : speed;\n    this[_clickedId] = '';\n    this[_easing] = [];\n    this[_speedMeasure] = {\n      start: undefined,\n      stop: undefined,\n      lastMeasuredAngle: undefined,\n      speedArr: [],\n      avgSpeed: undefined\n    };\n    this[_motionData] = {\n      isAboutToStop: false,\n      angleWhenClicked: undefined,\n      currentAngle: 0,\n      targetAngle: undefined,\n      move: true\n    };\n    this[_dynamicContent] = {\n      content: 1,\n      willUpdate: true\n    }\n  }\n\n  animateElement() {\n\n    if ( !this[_speedMeasure].avgSpeed ) this[_calculateEntryValues]();\n\n    if ( this[_motionData].move ){\n\n      let rotationSpeed = this[_computeRotatingTime]();\n\n      this[_computeAvgSpeed](rotationSpeed);\n      this[_updateContent]();\n\n      if (this[_easing].length !== 0) this[_applyEasing]();\n\n      if(this[_easing].length === 0 && this[_rotationSpeed] < this.baseSpeed) this[_accelerate]();\n\n\n      this[_motionData].currentAngle -= this[_rotationSpeed];\n      this[_motionData].currentAngle = this[_motionData].currentAngle <= -360 ? 0 : this[_motionData].currentAngle;\n\n      this.element.css( \"transform\", ` translateZ(-250px) rotateY(${this[_motionData].currentAngle}deg)` );\n\n      // targetAngle is set in click event, so after click event rotation will stop\n\n      if( Math.round(this[_motionData].currentAngle) === this[_motionData].targetAngle ){\n        this[_motionData].move = false;\n        this.element.css( \"transform\", ` translateZ(-250px) rotateY(${this[_motionData].targetAngle}deg)` )\n      }\n\n      window.requestAnimationFrame( ()=> this.animateElement() )\n    }\n    else {\n      this.animateFace();\n    }\n  }\n\n  animateFace(){\n\n    let myPlane = this.faces.filter( ( i,el ) => $(el).attr('id') === this[_clickedId]);\n\n    myPlane.addClass(\"focus\")\n  }\n\n  faceClickEvent(){\n\n    this.faces.on( 'click', (e)=> {\n\n      if( ! this[_motionData].isAboutToStop ){\n\n        let target = $(e.currentTarget);\n        e.stopPropagation();\n        this[_getTargetAngle](e);\n        this[_clickedId] = e.target.id;\n\n        let direction = this[_shouldChangeDirection]();\n\n        this[_motionData].isAboutToStop = true;\n        this[_easing] = this[_computeEasing](direction);\n        this[_motionData].angleWhenClicked = this[_motionData].currentAngle;\n\n        target.css('cursor', 'initial');\n\n        $('body')\n          .css('cursor', 'pointer')\n          .one('click', (e) => {\n            this[_motionData].isAboutToStop = false;\n            target.css('cursor', 'pointer');\n            $(e.currentTarget).css('cursor', 'initial');\n            this[_restoreAnimation]();\n          });\n      }\n    })\n  }\n\n  [_calculateEntryValues]() {\n    this[_speedMeasure].avgSpeed = (30 / ( this.baseSpeed * 60 ) );\n  }\n\n  [_computeRotatingTime](){\n\n    let currentAngle = Math.abs( Math.floor(this[_motionData].currentAngle) );\n    let rotationTime;\n    let flag = !(currentAngle % 31);\n\n    // return if current angle haven't change from last measurement\n    if (this[_speedMeasure].lastMeasuredAngle === currentAngle){\n      return null;\n    }\n\n\n    this[_speedMeasure].lastMeasuredAngle = currentAngle;\n\n\n    if(this[_speedMeasure].measureAngle === currentAngle){\n      this[_speedMeasure].stop = new Date();\n      rotationTime =  (this[_speedMeasure].stop - this[_speedMeasure].start)/1000;\n      return rotationTime;\n    }\n    //every 31 degrees start time, and angle, at which speed will be measured, are set\n    if ( flag ) {\n      this[_speedMeasure].measureAngle = this[_motionData].currentAngle === 360 ? 30 : currentAngle + 30;\n      this[_speedMeasure].start = new Date();\n    }\n    return null\n  }\n\n  [_computeEasing](direction){\n    let distance = Math.abs( Math.abs(this[_motionData].targetAngle) - Math.abs(this[_motionData].currentAngle) );\n\n    let steps = distance < 20 ? 5 : 10;\n    let threshold, delay, speed, speedChange, startEase, slowAngles, easing = [];\n    let baseSpeed = this[_rotationSpeed];\n\n    switch (true) {\n      case distance <= 10 :\n        delay = 0;\n        break;\n      case distance <= 20 :\n        delay = 3;\n        break;\n      case distance <= 30 :\n        delay = 8;\n        break;\n      case distance <= 40 :\n        delay = 15;\n        break;\n      case distance <= 50 :\n        delay = 24;\n        break;\n      case distance <= 60 :\n        delay = 32;\n        break;\n      case distance <= 70 :\n        delay = 40;\n        break;\n      case distance <= 80 :\n        delay = 50;\n        break;\n      case distance <= 90 :\n        delay = 60;\n        break;\n\n    }\n\n    threshold = ( distance - delay ) / steps;\n    speedChange = baseSpeed/steps;\n    speed = baseSpeed;\n    startEase = direction === \"forth\" ? this[_motionData].currentAngle - delay : this[_motionData].currentAngle + delay;\n    slowAngles = startEase;\n\n    threshold = direction === \"forth\" ? -threshold : threshold;\n\n\n    for(let i = 1; i < steps; i++){\n      slowAngles += threshold;\n      speed -= speedChange;\n\n      if ( speed > 0 ) speed = speed < 0.1 ? 0.1 : speed;\n      else speed = speed > -0.1 ? -0.1 : speed;\n\n      easing[i-1] = [];\n\n      easing[i-1].push( Math.round( slowAngles ) );\n      easing[i-1].push( parseFloat( speed.toFixed(2) ) );\n    }\n    return easing;\n\n  }\n  [_applyEasing](){\n\n    this[_easing].forEach(  value => {\n      if ( Math.round(this[_motionData].currentAngle) === value[0] )\n        this[_rotationSpeed] = value[1];\n    })\n  }\n\n  [_computeAvgSpeed](arg){\n\n    if ( arg === null ) return;\n\n    this[_speedMeasure].speedArr.push(arg);\n\n    if ( this[_speedMeasure].speedArr.length > 4 ){\n      this[_speedMeasure].speedArr.shift();\n\n    }\n    this[_speedMeasure].avgSpeed = this[_speedMeasure].speedArr.reduce((a,b) => a + b, 0) / this[_speedMeasure].speedArr.length;\n\n  }\n\n  [_getTargetAngle](e) {\n\n    const targetId = $(e.target).attr(\"id\");\n\n    switch (targetId) {\n      case \"front\":\n        this[_motionData].targetAngle = 0;\n        break;\n      case \"right\":\n        this[_motionData].targetAngle = -90;\n        break;\n      case \"back\":\n        this[_motionData].targetAngle = -180;\n        break;\n      case \"left\":\n        this[_motionData].targetAngle = -270;\n        break;\n    }\n  }\n\n  [_shouldChangeDirection](){\n    let direction = \"forth\";\n    if( this[_motionData].targetAngle === 0 ){\n      //if clicked in front plane, which set target angle to 0 , must have special check, cause current angle is always lesser than 0\n\n      this[_rotationSpeed] = this[_motionData].currentAngle < -180 ? this[_rotationSpeed] : - this[_rotationSpeed];\n\n      direction = this[_motionData].currentAngle < -180 ? \"forth\" :  \"back\"\n\n    } else if ( this[_motionData].currentAngle < this[_motionData].targetAngle ){\n      //all the other cases\n      this[_rotationSpeed] = -this[_rotationSpeed];\n      direction = \"back\"\n    }\n    return direction\n  }\n\n  [_restoreAnimation](){\n    let targetPlane = this.faces\n      .filter( ( i,el ) => $(el).attr('id') === this[_clickedId]);\n      targetPlane.removeClass(\"focus\");\n    this[_easing] = [];\n    this[_motionData].move = true;\n    this[_motionData].targetAngle = undefined;\n    this[_clickedId] = '';\n    this[_rotationSpeed] = this[_rotationSpeed] < 0 ? -this[_rotationSpeed] : this[_rotationSpeed];\n\n    targetPlane.one('transitionend',  () => {\n      this.animateElement();\n    })\n\n  }\n\n  [_accelerate](){\n    this[_rotationSpeed] =  parseFloat( ( this[_rotationSpeed] + 0.005 ).toFixed(3) );\n  }\n\n  [_updateContent](){\n\n    if ( this[_motionData].currentAngle < -10 && this[_motionData].currentAngle > -20 && this[_dynamicContent].willUpdate){\n\n      this[_dynamicContent].content = this[_rotationSpeed] > 0 ? this[_dynamicContent].content +2 : this[_dynamicContent].content;  //3/7/11...\n      this[_dynamicContent].willUpdate = false;\n\n      $(this.faces[2]).text(`face ${this[_dynamicContent].content}`);\n      $(this.faces[3]).text(`face ${this[_dynamicContent].content +1}`);\n\n    } else if (this[_motionData].currentAngle < -20 && this[_motionData].currentAngle > -30 && !this[_dynamicContent].willUpdate){\n\n      this[_dynamicContent].willUpdate = true\n\n    } else if ( this[_motionData].currentAngle < -190 && this[_motionData].currentAngle > -200 && this[_dynamicContent].willUpdate ){\n\n      this[_dynamicContent].content = this[_rotationSpeed] > 0 ? this[_dynamicContent].content +2 : this[_dynamicContent].content; // 5/9/13...\n      this[_dynamicContent].willUpdate = false;\n\n      $(this.faces[0]).text(`face ${this[_dynamicContent].content}`);\n      $(this.faces[1]).text(`face ${this[_dynamicContent].content + 1}`);\n\n    } else if ( this[_motionData].currentAngle < -200 && this[_motionData].currentAngle > -210 && !this[_dynamicContent].willUpdate){\n\n      this[_dynamicContent].willUpdate = true\n    }\n  }\n\n\n}\n\nlet myElement = new slider3d($('#top-layer'),.7);\n\n$(() => {\n\n\n  myElement.animateElement();\n  myElement.faceClickEvent();\n\n});\n"]}